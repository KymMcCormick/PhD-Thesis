---
title: "Eyewitness identification data analysis"
author: "Kym McCormick"
date: "15 May 2019"
output:
  word_document: default
  pdf_document: default
  html_notebook: default
---
```{r setup, include=FALSE, results='hide'}

knitr::opts_chunk$set(echo = TRUE)


library("psych", lib.loc="~/R/win-library/3.5")
library("tidyverse", lib.loc="~/R/win-library/3.5")
library("MPTinR", lib.loc="~/R/win-library/3.5")

setwd("C:/Users/mccormick/GitHub/PhD-Thesis")

data <- read.csv("data/Experiment 3/experiment3data.csv")


```

```{r data wrangling}

din <- data %>%
  
  ## Select required variables ---
  select(uid,
         condition, 
         Test_T1_suspectIdentified, 
         confidence_rating, 
         demographics_age, 
         demographics_gender, 
         demographics_country)%>%
  
  ## Only include data from USA and includes a confidence rating ----
  filter(demographics_country == "USA", !is.na(confidence_rating)) %>%
  
  ## Separate the confounded condition variable into separate variables ----
  separate(condition,c("memory","expectation","target")) %>%
  
  ## Create boolean variables for each identification outcome ---
  mutate(CID = if_else(target == "P" & Test_T1_suspectIdentified == "F68", 1, 0),
         Miss = if_else(target == "P" & Test_T1_suspectIdentified == "Silhouette", 1, 0),
         TPFoilID = if_else(target == "P" & Test_T1_suspectIdentified != "F68" & Test_T1_suspectIdentified != "Silhouette", 1, 0),
         CR = if_else(target == "A" & Test_T1_suspectIdentified == "Silhouette", 1, 0),
         TAFoilID = if_else(target == "A" & Test_T1_suspectIdentified != "Silhouette", 1, 0)
         )

## There are twice the number of target present lineups than target absent lineups. To rebalance this in a way that preserves the groupings of confidence intervals, I have chosen to double the Target Absent data before grouping into equal sized confidence rating bins. The following function does this and returns the data matrix with a new variable: decile.

Con_Perc <- function(data) {
  ## Separate data into target present and absent dataframes ---
  Ratings_Absent <- data %>% 
    filter(target == "A")
  
  Ratings_Present <- data %>%
    filter(target == "P")
  
  ## Bind back together, doubling up on the target absent group ---
  ## NOTE THAT DUPLICATES MAY BE REMOVED USING THE UID NUMBERS ---
  Ratings <- rbind(Ratings_Absent,Ratings_Absent,Ratings_Present)
  
  ## Group chooser confidence into decile confidence rating bins
  din_mod_choose <- Ratings %>%
    filter(Test_T1_suspectIdentified != "Silhouette") %>%
    mutate(decile_cr = ntile(confidence_rating,10)
    )
  
  ## Group non-chooser confidence into a single zero confidence rating bin
  din_mod_nochoose <- Ratings %>%
    filter(Test_T1_suspectIdentified == "Silhouette") %>%
    mutate(decile_cr = 0)
              
  ## Bind chooser and non-chooser data back together
  din_mod <- rbind(din_mod_choose, din_mod_nochoose)
  return(din_mod)
}

## Apply the above function to the cleaned dataset
din_mod <- Con_Perc(din)

## Check the grouping of the confidence rating deciles to ensure evenness
din_mod %>%
  select(decile_cr) %>%
  map(~prop.table(table(.)))

```


##Demographics                        
```{r demographics}

age <- describe(din$demographics_age)
age

gender <- din %>% 
  select(demographics_gender) %>% 
  map(~prop.table(table(.)))
gender
```
##Identification counts

```{r Identification counts}
## Counts within each confidence level and accross manipulation groups ---
ID_count <- din_mod %>% 
  group_by(decile_cr,memory,expectation) %>%
  summarise(
    Miss = sum(Miss),
    TPFID = sum(TPFoilID),
    Correct_ID = sum(CID),
    CR = sum(CR),
    TAFID = sum(TAFoilID)*7/8,
    False_ID = sum(TAFoilID)/8,
    TP = sum(Miss,TPFoilID,CID),
    TA = sum(CR,TAFID,False_ID)
    ) %>%
  ungroup()

head(ID_count,10)

```

##ROC data
```{r}
## Creating ROC data 


ROC <- ID_count %>%
  ## Group by binned confidence level groups ---
  group_by(decile_cr) %>%
  
  ## Find sums for correct identifications, false identifications, and the size of the target present and target absent groups --- 
  summarise(
    Correct_ID = sum(Correct_ID),
    False_ID = sum(False_ID),
    TA = sum(TA),
    TP = sum(TP)
    ) 

## Reverse the order of the confidence level groups (from highest to lowest) ---
ROC <- ROC[11:1,]

## Calculate the cummulative counts ---
ROC <- ROC %>%
  mutate(
    Correct_ID_cum = cumsum(Correct_ID),
    False_ID_cum = cumsum(False_ID)
    )%>%
  ## Calclate the cummulative CID and FID proportions --- 
  ungroup()%>%
  mutate(
    CID = Correct_ID_cum/sum(TP),
    FID = False_ID_cum/sum(TA)
    )

ROC
```
###Plotting ROC 
```{r}
library(ggplot2)
# Basic scatter plot
ggplot(ROC, aes(x=FID, y=CID)) + 
  geom_point() +
  xlim(0,.1) +
  ylim(0,.5) +
  ggtitle("ROC eyewitness memory")
```
##ROC by levels of memory
```{r}
## Creating ROC data for each manipulation group 


ROC_memory <- ID_count %>%
  ## Group by binned confidence level groups ---
  group_by(decile_cr, memory) %>%
  
  ## Find sums for correct identifications, false identifications, and the size of the target present and target absent groups --- 
  summarise(
    Correct_ID = sum(Correct_ID),
    False_ID = sum(False_ID),
    TA = sum(TA),
    TP = sum(TP)
    )  %>%
  ungroup()

## Reverse the order of the confidence level groups (from highest to lowest) ---
ROC_memory <- ROC_memory[22:1,]
head(ROC_memory,10)
```

```{r ROC weak memory}
## Calculate the cummulative counts for weak memory---
ROC_W <- ROC_memory %>%
  filter(memory == "W") %>%
  mutate(
    Correct_ID_cum = cumsum(Correct_ID),
    False_ID_cum = cumsum(False_ID)
    ) %>%
  ## Calclate the cummulative CID and FID proportions --- 
  mutate(
    CID = Correct_ID_cum/sum(TP),
    FID = False_ID_cum/sum(TA)
     )
ROC_W
```
```{r ROC strong memory}
## Calculate the cummulative counts for strong memory---
ROC_S <- ROC_memory %>%
  filter(memory == "S") %>%
  mutate(
    Correct_ID_cum = cumsum(Correct_ID),
    False_ID_cum = cumsum(False_ID)
    ) %>%
  ## Calclate the cummulative CID and FID proportions --- 
  mutate(
    CID = Correct_ID_cum/sum(TP),
    FID = False_ID_cum/sum(TA)
     )

ROC_S
```
```{r}
combined <- ROC%>%
  filter(decile_cr != "0")%>%
  select(CID,FID)%>%
  mutate(
    nCID =1-CID,
    nFID = 1-FID
  )%>%
  select(CID,nCID,FID,nFID)%>%
  t()%>%
  as.vector()
combined

strong <- ROC_S %>%
  filter(decile_cr != "0")%>%
  select(CID,FID)%>%
  mutate(
    nCID =1-CID,
    nFID = 1-FID
  )%>%
  select(CID,nCID,FID,nFID)%>%t()%>%
  as.vector()
strong

weak <- ROC_S %>%
  filter(decile_cr != "0")%>%
  select(CID,FID)%>%
  mutate(
    nCID =1-CID,
    nFID = 1-FID
  )%>%
  select(CID,nCID,FID,nFID)%>%t()%>%
  as.vector()
weak

```



```{r}
ggplot(ROC, aes(x=FID, y=CID)) + 
  geom_point(data = ROC,  colour = 'black', shape = 1) +
  geom_point(data = ROC_S,  colour = 'blue', shape = 2) +
  geom_point(data = ROC_W,  colour = 'blue', shape = 3) +
  xlim(0,.1) +
  ylim(0,.6)+ 
  ggtitle("ROC Eyewitness data (by memory strenghth)")
```

```{r fit UVSDT model to all outcomes, echo=FALSE}
IndObvSDT_eyewit <- function(Q, data, param.names, n.params, tmp.env){
  n <- 8 
  mean <- Q[1]
  sd <- Q[2]
  cr <- c(Q[3:12])  #confidence criterion
  v <- vector()
  for (i in 1:length(cr)) {
    TID <-  integrate(
      f = function(x){
        dnorm(x,mean,sd)*(pnorm(x,0,1)^(n-1))
        },
      lower = cr[i],
      upper = Inf
      )$value
    FID <- (n-1)*(integrate(
      f = function(x) {
        dnorm(x,0,1)*pnorm(x,mean,sd)*(pnorm(x,0,1)^(n-2))
        },
      lower = cr[i],
      upper = Inf
      )$value
    )
    FA <- (1-pnorm(cr[i])^n)/n
    TD <- 1-(pnorm((mean-cr[i])/sd)*(pnorm(cr[i])^(n-1)))
    I <- c(
      t(
        cbind(
          (1-(FID+TID)),#Miss (TP)
          FID,          #Foil ID (TP)
          TID,          #Target ID
          1-FA,           #Correct Rejection (TA)
          FA*(n-1)/n,     #Foil ID (TA)
          FA              #False ID (TA)
        )
      )
    )
v <- cbind(v,I)
  }
  Outcomes <- c(t(v))
  return(Outcomes)
}

IndObvMLE <- function(Q, data, param.names, n.params, tmp.env, lower.bound, upper.bound){

    e <- IndObvSDT_eyewit(Q, param.names, n.params, tmp.env)
    LL <- -sum(data[data!=0]*log(e[data!=0]))

   

    return(LL)

}

#fit_kafc <- fit.mptinr(    data = ID_cum_vector,    objective = IndObvMLE,    param.names = c("mu", "sigma", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7", "cr8", "cr9", "cr10"),    categories.per.type = c(6,6,6,6,6,6,6,6,6,6),    prediction = IndObvSDT_eyewit,    lower.bound = c(0,0.1,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf),    upper.bound = Inf,    n.optim = 5,    #starting.values = c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),    show.messages = FALSE)

#fit_kafc$goodness.of.fit
#fit_kafc$parameters
```



```{r fit UVSDT model to identification outcomes only}

UVSDT_eyewit <- function(Q, data, param.names, n.params, tmp.env){
  n <- 8 
  mean <- Q[1]
  sd <- Q[2]
  cr <- c(Q[3:12])  #confidence criterion
  v <- vector()
  for (i in 1:length(cr)) {
    CID <-  integrate(
      f = function(x){
        dnorm(x,mean,sd)*(pnorm(x,0,1)^(n-1))
        },
      lower = cr[i],
      upper = Inf
      )$value
    FA <- (1-pnorm(cr[i])^n)/n
    I <- c(
      t(
        cbind(CID, (1-CID), FA, 1-(FA))
      )
    )
v <- cbind(v,I)
  }
  Outcomes <- c(t(v))
  return(Outcomes)
}
 

IndObvMLE2 <- function(Q, data, param.names, n.params, tmp.env, lower.bound, upper.bound){
    e <- UVSDT_eyewit(Q, param.names, n.params, tmp.env)
    LL <- -sum(data[data!=0]*log(e[data!=0]))
    return(LL)
}

fit_kafc <- fit.mptinr(
    data = weak,
    objective = IndObvMLE2,
    param.names = c("mu", "sigma", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7", "cr8", "cr9", "cr10"),
    categories.per.type = c(4,4,4,4,4,4,4,4,4,4),
    prediction = UVSDT_eyewit,
    lower.bound = c(0,0.1,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf),
    upper.bound = Inf,
    n.optim = 5,
    starting.values = c(0,0,0,0,0,0,0,0,0,0,0,0),
    show.messages = FALSE
)

fit_kafc$goodness.of.fit

fit_kafc$parameters
```


```{r}
fit_kafc <- fit.mptinr(
    data = strong,
    objective = IndObvMLE2,
    param.names = c("mu", "sigma", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7", "cr8", "cr9", "cr10"),
    categories.per.type = c(4,4,4,4,4,4,4,4,4,4),
    prediction = UVSDT_eyewit,
    lower.bound = c(0,0.1,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf),
    upper.bound = Inf,
    n.optim = 5,
    starting.values = c(0,0,0,0,0,0,0,0,0,0,0,0),
    show.messages = FALSE
)

fit_kafc$goodness.of.fit

fit_kafc$parameters

```


